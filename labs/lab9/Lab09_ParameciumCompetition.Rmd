---
title: "Lab 9: Competition"
subtitle: 'EFB 370 - Spring 2023'
author: "Elie Gurarie and Katya Khadonova"
date: "`r Sys.Date()`"
output: 
  html_document: 
    toc: true
    toc_float: true
---


> ### Goals: 
> 1. To attempt to fit a competition model to actual data, namely Gause's famous  two-paremecium system. 
> 2. To practice loading data, using functions, and performing numerical experimentation in R
> 3. There are **5** exercises in this lab to submit by midnight next Monday, April 3.   

```{css, echo = FALSE}
blockquote {
    padding: 10px 20px;
    margin: 0 0 20px;
    font-size: 16px;
    color: darkgreen;
    font-family: "Garamond";
    background: #DFD;
    border-left: 5px solid #262; 
}
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Note - you can copy-paste code from this lab into your R-studio, but do so carefully and place it into a script, which you can save later as an `.R` file. 


<center> 
![](gausefigure.png)

**Figure 1** (Gause 1934) </center>

## Step 1. Load data

There are two datasets posted on Blackboard or [here](single.csv) and [here](mixture.csv): `single.csv` and `mixture.csv`.  

Load these into `R`, using using the `FILE/IMPORT DATADET` point and click or ... better ... using the `read.csv()` command as follows:

```{r}
single <- read.csv("single.csv")
mixture <- read.csv("mixture.csv")
```

> **Q1.** What do these datasets represent?

## Step 2. Plot these data

There are multiple ways to do this.  For example, both of the following do the same thing:

```{r, eval = FALSE}
plot(single$Day, single$caudatum)
plot(caudatum~Day, data = single)
```

You can make plots prettier in different ways. Compare the following:

```{r, eval = FALSE}
plot(caudatum~Day, data = single, type = "l")
plot(caudatum~Day, data = single, type = "o")
plot(caudatum~Day, data = single, type = "o", col = "blue")
```

The `plot()` function makes a new plot, but you can also add points to an existing plot with the `points()` or `lines()` function.  For example, see the following code:

```{r}
plot(aurelia~Day, type="o", data = single, col = "darkorange")
lines(caudatum~Day, data = single, type = "o", col = "darkblue")
```


> **Q2.** Use `R` to load the `mixture.R` dataset and plot those two curves - in blue and orange - on the same figure as well.


```{r, echo = FALSE, eval=FALSE}
plot(aurelia~Day, type="o", data = mixture, col = "darkorange")
lines(caudatum~Day, data = mixture, type = "o", col = "darkblue")
```


## Step 3. Load some functions

Now - download and open the `fittingfunctions.R` file, from Blackboard or [here](fittingfunctions.R).  Run the entire code in that file, either selecting all (`Ctrl-A`) and running (`Ctrl-Enter`), clicking on the `Source` button under `Run` up top or (simple yet fancy), run the `source` command as follows:

```{r}
source("fittingfunctions.R")
```

There are a bunch of functions in here that allow you to experiment with logistic and competition models.  For example, to fit the logistic curve to one of the paramecium data sets, just do:

```{r}
fitLogistic(y = "aurelia", time = "Day", data = single)
```

If you save the output of this function (as an `R` object), you can draw the curve on your figure as well using the `linesLogistic()` function:

```{r}
au.fit <- fitLogistic(y = "aurelia", time = "Day", data = single)
plot(aurelia~Day, type="o", data = single)
linesLogistic(au.fit)
```

> **Q3:**  Make the fit line fat and red by adding the following to your `linesLogistic` function: `linesLogistic(au.fit, lwd = 2, col = "red")`
>
> **Q4:** Perform the same fit for *P. caudatum* and report the estimates.  


## Step 4. Experiment with the Competition Simulator

The `simulateCompetition()` function numerically generates the 2 species process we discussed in class, i.e.: 

$${dN_1 \over dt} = r_1 N \left(1-{N_1 \over K_1} - \alpha {N_2\over K_1}\right)$$
$${dN_2 \over dt} = r_2 N \left(1-{N_2 \over K_2} - \beta { N_1\over K_2}\right)$$


Where everything is familiar, except there is also an $\alpha$ which cuts $N_1$ down based on how many $N_2$ there are, and a $\beta$ which cuts $N_2$ down based on how many $N_1$ there are.  

The way it works is as follows.  You first enter a bunch of parameter values in, for example: 


```{r}
pars <- list(K1 = 100, K2 = 100, 
             r1 = 1, r2 = 1,
             alpha = 2, beta = 1,
             n1 = 20, n2 = 10)
```

Then, you can pass these parameters all at once into a simulation function, and save the output into an object, here called `mysim`:

```{r}
mysim <- simulateCompetition(tmax = 24, tstart = 2, pars)
```

Look at the struction of `mysim`: 

```{r}
head(mysim)
```


You can plot this, just as above.  But I helpfully provided a function that does this for you:

```{r}
simPlot(mysim)
```

Furthermore, you can plot this on top of a data set, which is nice.  For example:

```{r}
simPlot(mysim, data = mixture, species1 = "aurelia", species2 = "caudatum")
```

Obviously, this is not a very good fit!   I also wrote a function which quantifies how lousy of a fit this is using $R^2$.  The closer $R^2$ is to 1, the better. That function works like this:

```{r}
getR2(mysim, data = mixture, species1 = "aurelia", species2 = "caudatum")
```

Yikes!  Those are really bad numbers.  They're so far from 1, they're negative. 


> **Q5 or The Challenge:**  Experiment with this system and see if you can find values of $\alpha$ (effect of *caudatum* on *aurelia*) and $\beta$ (effect of *aurelia* on *caudatum*) which more or less captures the competition process observed in the data.  How high can you get the $R^2$ value to go?  


Note - to do the above you basically just have to copy paste the following lines of code, adjust the numbers in the `pars` object, and keep experimenting.  But use the following values as fixed:  $K_1 = 210$, $K_2 = 235$,  $N_1 = N_2 = 5$.  That leaves $\alpha$, $\beta$, $r_1$ and $r_2$ to play with:

```{r, eval = FALSE}
pars <- list(K1 = 222, K2 = 202, 
             r1 = 0.71, r2 = 0.96,
             alpha = 0, beta = 0,
             n1 = 1.28, n2 = 0.2)

mysim <- simulateCompetition(tmax = 24, tstart = 2, pars)
simPlot(mysim, data = mixture, species1 = "aurelia", species2 = "caudatum")
getR2(mysim, data = mixture, species1 = "aurelia", species2 = "caudatum")
```

How close can you get yout $R^2$ values to 1?  


```{r, eval = FALSE, echo = FALSE}
# here's a good set of values
pars <- list(K1 = 210, K2 = 235, 
             r1 = 1, r2 = 1.1,
             alpha = 1, beta = 1.4,
             n1 = 5, n2 =5)

```


### Bonus on logistic

These functions, by the way, work great on the logistic data as well, where there is NO competition:

```{r}
pars <- list(K1 = 222, K2 = 202, 
             r1 = 0.71, r2 = 0.96,
             alpha = 0, beta = 0,
             n1 = 1.28, n2 = 0.2)

mysim <- simulateCompetition(tmax = 24, tstart = 0, pars, dt = 0.001)
simPlot(mysim, data = single, species1 = "aurelia", species2 = "caudatum")
getR2(mysim, data = single, species1 = "aurelia", species2 = "caudatum")
```

```{r, eval = FALSE, echo = FALSE}
mixture  <- plyr::mutate(mixture, dc = c(NA, diff(caudatum)), da = c(NA, diff(aurelia)))
head(mixture)

with(mixture, plot(caudatum, aurelia, type = "l", xlim = c(0,220), ylim = c(0,220), asp = 1))
```



```{r, echo = FALSE,eval = FALSE}

require(deSolve)
competition <- function(times, y, parameters) {
      with(as.list(c(y, parameters)), {
          dN1 <- r1 * N1 * (1 - N1/K1 - alpha * N2/K1)
          dN2 <- r2 * N2 * (1 - N2/K2 - beta * N1/K2)
          return(list(c(dN1, dN2)))
      })
}

runCompetition <- function(times,
                            parms = c(r1, r2,  K1, K2, alpha, beta, n1, n2)){
    yini <- c(N1 = as.numeric(parms["n1"]), 
              N2 = as.numeric(parms["n2"]))
    ode(y = yini, times = times, func = competition, 
        parms = parms[1:6])
}

getSSR <- function(p, data, w = weights, time = "Day"){
    sim <- runCompetition(data[,time], p)
    sum(sqrt((sim[,2:3] - data[,2:3])^2)*w)
}

pars <- list(r1 = .7, r2 = .95,
             K1 = 222, K2 = 202, 
             alpha = 0, beta = 0,
             n1 = 1.2, n2 = .21)
pars.low <- lapply(pars, function(x) x*0)
pars.high <- lapply(pars, function(x) x*Inf)
pars.low$r2 <- 0.5
pars.high$r2 <- 1.5
pars.low$r2 <- 0.5
pars.high$r2 <- 1.5



pars.low$K1 <- 200
pars.high$K1 <- 250
pars.low$K2 <- 200
pars.high$K2 <- 250

require(magrittr)
weights <-  apply(1/mixture[,2:3], 2, scale) %>% 
    apply(2, function(x) x - min(x)) %>% sqrt %>% apply(2, mean)

matplot(weights, type = "l")

system.time(fitCompetition <- optim(par = pars, getSSR, data = mixture,
                                     lower = pars.low, upper = pars.high, 
                                     method = "L-BFGS-B", w= weights))
(p.hat <- fitCompetition$par)


```


